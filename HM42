local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
    Name = "ComboChronicle Vault | Weird Gun Game",
    Icon = 12345678901, --  diamond icon ID? 
    LoadingTitle = "Loading ComboChronicle Vault ❖",
    LoadingSubtitle = "By COMBO_WICK | Bang.E.Line",
    Theme = "Ocean"
})

-- Services
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

-- Local Player
local LocalPlayer = Players.LocalPlayer

-- Toggles
local aimbotEnabled = false
local autoLockEnabled = false
local trickshotMode = false
local fovRadius = 100
local aimPart = "Head" -- Options: "Head", "Torso", "Random"
local smoothingFactor = 5 -- Higher = slower and smoother aiming

-- Hitbox size variables
local headHitboxSize = 9
local rootHitboxSize = 10

-- Teammate toggles
local excludeTeammatesESP = false
local excludeTeammatesHitbox = false

-- Variables
local Camera = Workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()

-- Store death and kill position variables
local teleportDistance = 10  -- Distance in front of the local player to teleport others
local teleporting = false  -- Toggle for continuous teleportation
local checkInterval = 0.5  -- Time between teleportation checks

local espEnabled = false
local hitboxEnabled = false

-- Function to enable infinite jump
local infiniteJumpEnabled = false
game:GetService("UserInputService").JumpRequest:Connect(function()
    if infiniteJumpEnabled then
        game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):ChangeState("Jumping")
    end
end)

-- Function for speed and jump power modification
local function modifyCharacterStats(speed, jump)
    local player = game.Players.LocalPlayer
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        player.Character.Humanoid.WalkSpeed = speed
        player.Character.Humanoid.JumpPower = jump
    end
end

-- Function for no clip
local noclipEnabled = false
game:GetService('RunService').Stepped:Connect(function()
    if noclipEnabled then
        for _, part in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end
end)

-- Helper function to check if a player is a teammate
local function isTeammate(player)
    local localPlayer = game.Players.LocalPlayer
    return player ~= localPlayer and player.Team == localPlayer.Team
end

-- Function to teleport to a specified position
local function teleportToPosition(position)
    local player = game.Players.LocalPlayer
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.CFrame = CFrame.new(position)
    end
end

-- ESP Logic
local function addESP(character)
    if character and character:FindFirstChild("Head") then
        local player = game.Players:GetPlayerFromCharacter(character)
        if player and (not excludeTeammatesESP or not isTeammate(player)) then
            if not character:FindFirstChild("ESP_Highlight") then
                local highlight = Instance.new("Highlight")
                highlight.Name = "ESP_Highlight"
                highlight.Adornee = character
                highlight.FillColor = Color3.new(0, 1, 0) -- Green color
                highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                highlight.Parent = character
            end
        end
    end
end

local function removeESP(character)
    local highlight = character:FindFirstChild("ESP_Highlight")
    if highlight then
        highlight:Destroy()
    end
end

-- Function to track players and apply ESP on respawn
local function monitorPlayerESP(player)
    if player ~= game.Players.LocalPlayer then
        if player.Character then
            addESP(player.Character)
        end
        -- Listen for respawn and apply ESP again
        player.CharacterAdded:Connect(function(character)
            task.wait(0.5) -- Small delay to ensure the character fully loads
            addESP(character)
        end)
    end
end

-- Apply ESP to existing players and listen for new ones
for _, player in pairs(game.Players:GetPlayers()) do
    monitorPlayerESP(player)
end

-- Listen for new players joining the game
game.Players.PlayerAdded:Connect(monitorPlayerESP)

-- Function to teleport players (TEAMMATE VERSION)
local function teleportMovingPlayers()
    local localPlayer = game.Players.LocalPlayer
    local character = localPlayer.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        local rootPart = character.HumanoidRootPart
        local camera = workspace.CurrentCamera
        local cameraDirection = camera.CFrame.LookVector
        local cameraPosition = camera.CFrame.Position
        
        -- Loop through all players and teleport them if they're moving and not on the same team
        for _, player in pairs(game.Players:GetPlayers()) do
            if player.Character and player ~= localPlayer and player.Team ~= localPlayer.Team then
                local targetCharacter = player.Character
                local humanoid = targetCharacter:FindFirstChild("Humanoid")
                local targetRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
                
                -- Ensure the player has a humanoid and is moving
                if targetRootPart and humanoid and humanoid.MoveDirection.magnitude > 0 then
                    -- Calculate the new position directly in front of the local player
                    local newPosition = cameraPosition + cameraDirection * teleportDistance
                    
                    -- Use Raycast to check and correct the Y position (for grounding)
                    local ray = Ray.new(newPosition, Vector3.new(0, -10, 0))  -- Check downwards for ground
                    local hit, hitPosition = workspace:FindPartOnRay(ray, targetCharacter)
                    
                    -- Set the new position of the player
                    if hit then
                        targetRootPart.CFrame = CFrame.new(hitPosition.X, hitPosition.Y, hitPosition.Z)
                    else
                        -- Default position if no ground found
                        targetRootPart.CFrame = CFrame.new(newPosition)
                    end
                    
                    -- Remove any BodyGyros or other constraints that may interfere with player interaction
                    for _, v in pairs(targetCharacter:GetChildren()) do
                        if v:IsA("BodyGyro") or v:IsA("BodyPosition") then
                            v:Destroy()
                        end
                    end

                    -- Prevent them from being teleported back to their original position
                    targetCharacter:MoveTo(hitPosition or newPosition)
                    
                    -- Anchor the player to prevent floating
                    targetRootPart.Anchored = true
                    
                    -- Allow the player to interact (e.g., get damaged or killed) after teleporting
                    if humanoid then
                        humanoid.PlatformStand = false  -- Ensure the humanoid is not locked in place
                    end

                    -- Ensure collision is enabled for the player after teleportation
                    humanoid:ChangeState(Enum.HumanoidStateType.Physics)
                end
            end
        end
    end
end

-- Function to teleport players (FREE-FOR-ALL)
local function teleportMovingPlayers2()
    local localPlayer = game.Players.LocalPlayer
    local character = localPlayer.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        local rootPart = character.HumanoidRootPart
        local camera = workspace.CurrentCamera
        local cameraDirection = camera.CFrame.LookVector
        local cameraPosition = camera.CFrame.Position
        
        -- Loop through all players and teleport them if they're moving
        for _, player in pairs(game.Players:GetPlayers()) do
            if player.Character and player ~= localPlayer then
                local targetCharacter = player.Character
                local humanoid = targetCharacter:FindFirstChild("Humanoid")
                local targetRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
                
                -- Ensure the player has a humanoid and is moving
                if targetRootPart and humanoid and humanoid.MoveDirection.magnitude > 0 then
                    -- Calculate the new position directly in front of the local player
                    local newPosition = cameraPosition + cameraDirection * teleportDistance
                    
                    -- Use Raycast to check and correct the Y position (for grounding)
                    local ray = Ray.new(newPosition, Vector3.new(0, -10, 0))  -- Check downwards for ground
                    local hit, hitPosition = workspace:FindPartOnRay(ray, targetCharacter)
                    
                    -- Set the new position of the player
                    if hit then
                        targetRootPart.CFrame = CFrame.new(hitPosition.X, hitPosition.Y, hitPosition.Z)
                    else
                        -- Default position if no ground found
                        targetRootPart.CFrame = CFrame.new(newPosition)
                    end
                    
                    -- Remove any BodyGyros or other constraints that may interfere with player interaction
                    for _, v in pairs(targetCharacter:GetChildren()) do
                        if v:IsA("BodyGyro") or v:IsA("BodyPosition") then
                            v:Destroy()
                        end
                    end

                    -- Prevent them from being teleported back to their original position
                    targetCharacter:MoveTo(hitPosition or newPosition)
                    
                    -- Anchor the player to prevent floating
                    targetRootPart.Anchored = true
                    
                    -- Allow the player to interact (e.g., get damaged or killed) after teleporting
                    if humanoid then
                        humanoid.PlatformStand = false  -- Ensure the humanoid is not locked in place
                    end

                    -- Ensure collision is enabled for the player after teleportation
                    humanoid:ChangeState(Enum.HumanoidStateType.Physics)
                end
            end
        end
    end
end

-- Function to apply hitbox modifications (only for non-teammates when excludeTeammatesHitbox is true)
local function adjustHitbox(character)
    if not character or not hitboxEnabled then return end

    local player = game.Players:GetPlayerFromCharacter(character)
    if not player or player == LocalPlayer then return end -- Skip local player

    -- Check teammate status and exclusion toggle
    if excludeTeammatesHitbox and isTeammate(player) then
        -- Reset teammate hitbox to default if modified
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if rootPart and (rootPart.Size.X > 2 or rootPart.Transparency > 0) then
            rootPart.Size = Vector3.new(2, 2, 1)
            rootPart.Transparency = 0
            rootPart.CanCollide = true
        end
        local head = character:FindFirstChild("Head")
        if head and (head.Size.X > 1 or head.Transparency > 0) then
            head.Size = Vector3.new(1, 1, 1)
            head.Transparency = 0
            head.CanCollide = true
        end
        return
    end

    -- Apply hitbox modifications only to non-teammates
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if rootPart then
        rootPart.Size = Vector3.new(rootHitboxSize, rootHitboxSize, rootHitboxSize)
        rootPart.Transparency = 0.5
        rootPart.CanCollide = false
    end

    local head = character:FindFirstChild("Head")
    if head then
        head.Size = Vector3.new(headHitboxSize, headHitboxSize, headHitboxSize)
        head.Transparency = 0.5
        head.CanCollide = false
    end
end

-- Function to reset hitbox to default
local function resetHitbox(character)
    if not character then return end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if rootPart then
        rootPart.Size = Vector3.new(2, 2, 1)
        rootPart.Transparency = 0
        rootPart.CanCollide = true
    end
    local head = character:FindFirstChild("Head")
    if head then
        head.Size = Vector3.new(1, 1, 1)
        head.Transparency = 0
        head.CanCollide = true
    end
end

-- Function to monitor a player for hitbox
local function monitorPlayerHitbox(player)
    if player == LocalPlayer then return end -- Skip local player

    -- Apply or reset hitbox on initial character load
    if player.Character then
        if hitboxEnabled and (not excludeTeammatesHitbox or not isTeammate(player)) then
            adjustHitbox(player.Character)
        else
            resetHitbox(player.Character)
        end
    end

    -- Listen for respawns and apply/reset hitbox accordingly
    player.CharacterAdded:Connect(function(character)
        task.wait(0.5) -- Wait for character to load
        if hitboxEnabled and (not excludeTeammatesHitbox or not isTeammate(player)) then
            adjustHitbox(character)
        else
            resetHitbox(character)
        end
    end)
end

-- Monitor all players currently in the game for hitbox
for _, player in pairs(game.Players:GetPlayers()) do
    monitorPlayerHitbox(player)
end

-- Listen for new players joining
game.Players.PlayerAdded:Connect(monitorPlayerHitbox)

-- Helper Functions
local function getClosestEnemyTarget()
    local localPlayer = game.Players.LocalPlayer
    local mouse = localPlayer:GetMouse()
    local closestDistance = fovRadius
    local closestPlayer = nil

    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild(aimPart) then
            local targetPart = player.Character[aimPart]

            -- Make sure it's an enemy, not a teammate (using Team-based checks)
            if player.Team ~= localPlayer.Team then
                local screenPosition, onScreen = workspace.CurrentCamera:WorldToScreenPoint(targetPart.Position)

                if onScreen then
                    local distance = (Vector2.new(screenPosition.X, screenPosition.Y) - Vector2.new(mouse.X, mouse.Y)).Magnitude
                    if distance < closestDistance then
                        closestDistance = distance
                        closestPlayer = targetPart
                    end
                end
            end
        end
    end

    return closestPlayer
end

local function aimAtTarget(target)
    if target then
        local camera = workspace.CurrentCamera
        local targetPosition = target.Position
        local currentPosition = camera.CFrame.Position

        local direction = (targetPosition - currentPosition).Unit
        local newCFrame = CFrame.new(currentPosition, currentPosition + direction)

        camera.CFrame = camera.CFrame:Lerp(newCFrame, 1 / smoothingFactor)
    end
end

-- Main Aimbot Functionality
local function aimbotLoop()
    while task.wait() do
        if aimbotEnabled then
            local target = getClosestEnemyTarget()
            aimAtTarget(target)
        end
    end
end

task.spawn(aimbotLoop)

-- Main Tab
local mainTab = Window:CreateTab("Main", 4483362458)

local Label = mainTab:CreateLabel("NOTE: Beta! More feature might come. Might not work on every executor", 4483362458, Color3.fromRGB(34, 193, 34), false) -- Title, Icon, Color, IgnoreTheme

mainTab:CreateToggle({
    Name = "Kill All(TeamMates Game Mode)",
    CurrentValue = teleporting,
    Callback = function(value)
        teleporting = value
        if teleporting then
            while teleporting do
                teleportMovingPlayers()
                wait(checkInterval)
            end
        end
    end,
})

mainTab:CreateToggle({
    Name = "Kill All(FREE-FOR-ALL GAME MODE)",
    CurrentValue = teleporting,
    Callback = function(value)
        teleporting = value
        if teleporting then
            while teleporting do
                teleportMovingPlayers2()
                wait(checkInterval)
            end
        end
    end,
})

mainTab:CreateToggle({
    Name = "Toggle ESP(Do it MANUALLY lmao)",
    CurrentValue = espEnabled,
    Callback = function(value)
        espEnabled = value
        for _, player in pairs(game.Players:GetPlayers()) do
            if player.Character then
                if espEnabled then
                    addESP(player.Character)
                else
                    removeESP(player.Character)
                end
            end
        end
    end
})

mainTab:CreateToggle({
    Name = "Exclude Teammates from ESP",
    CurrentValue = excludeTeammatesESP,
    Callback = function(value)
        excludeTeammatesESP = value
        for _, player in pairs(game.Players:GetPlayers()) do
            if player.Character then
                removeESP(player.Character)
                if espEnabled then
                    addESP(player.Character)
                end
            end
        end
    end
})

mainTab:CreateToggle({
    Name = "Enable Hitbox",
    CurrentValue = false,
    Callback = function(value)
        hitboxEnabled = value
        for _, player in pairs(game.Players:GetPlayers()) do
            if player.Character then
                if hitboxEnabled and (not excludeTeammatesHitbox or not isTeammate(player)) then
                    adjustHitbox(player.Character)
                else
                    resetHitbox(player.Character)
                end
            end
        end
    end
})

mainTab:CreateToggle({
    Name = "Exclude Teammates from Hitbox",
    CurrentValue = excludeTeammatesHitbox,
    Callback = function(value)
        excludeTeammatesHitbox = value
        for _, player in pairs(game.Players:GetPlayers()) do
            if player.Character then
                if hitboxEnabled and (not excludeTeammatesHitbox or not isTeammate(player)) then
                    adjustHitbox(player.Character)
                else
                    resetHitbox(player.Character)
                end
            end
        end
    end
})

mainTab:CreateSlider({
    Name = "Head Hitbox Size",
    Range = {1, 20},
    Increment = 1,
    CurrentValue = headHitboxSize,
    Callback = function(value)
        headHitboxSize = value
        if hitboxEnabled then
            for _, player in pairs(game.Players:GetPlayers()) do
                if player.Character and (not excludeTeammatesHitbox or not isTeammate(player)) then
                    adjustHitbox(player.Character)
                end
            end
        end
    end
})

mainTab:CreateSlider({
    Name = "Root Hitbox Size",
    Range = {1, 20},
    Increment = 1,
    CurrentValue = rootHitboxSize,
    Callback = function(value)
        rootHitboxSize = value
        if hitboxEnabled then
            for _, player in pairs(game.Players:GetPlayers()) do
                if player.Character and (not excludeTeammatesHitbox or not isTeammate(player)) then
                    adjustHitbox(player.Character)
                end
            end
        end
    end
})

mainTab:CreateSlider({
    Name = "Speed Hack",
    Range = {16, 500},
    Increment = 1,
    Suffix = "Speed",
    CurrentValue = 16,
    Callback = function(Value)
        modifyCharacterStats(Value, game.Players.LocalPlayer.Character.Humanoid.JumpPower)
    end,
})

mainTab:CreateSlider({
    Name = "Jump Power",
    Range = {50, 500},
    Increment = 1,
    Suffix = "Power",
    CurrentValue = 50,
    Callback = function(Value)
        modifyCharacterStats(game.Players.LocalPlayer.Character.Humanoid.WalkSpeed, Value)
    end,
})

mainTab:CreateToggle({
    Name = "Infinite Jump",
    CurrentValue = false,
    Callback = function(Value)
        infiniteJumpEnabled = Value
    end,
})

mainTab:CreateToggle({
    Name = "Noclip",
    CurrentValue = false,
    Callback = function(Value)
        noclipEnabled = Value
    end,
})

-- Credits Tab
local CreditsTab = Window:CreateTab("✨ Credits", "info")
local CreatorSection = CreditsTab:CreateSection("👑 Creator")
CreditsTab:CreateLabel("🛠️ COMBO_WICK - Discord: world_star_hacker")
local CoDevSection = CreditsTab:CreateSection("🤝 Co-Developer")
CreditsTab:CreateLabel("💡 None - Discord: None")
local DiscordSection = CreditsTab:CreateSection("🌐 Discord Server")
CreditsTab:CreateLabel("🔗 Join our server: discord.com/invite/mwTHaCKzhw")
CreditsTab:CreateButton({
   Name = "📋 Copy Discord Link/Youtube",
   Callback = function()
      local links = "Discord: discord.com/invite/mwTHaCKzhw\nYouTube: https://www.youtube.com/@COMBO_WICK"
      setclipboard(links)
   end,
})

-- Aimbot Tab
local AimbotTab = Window:CreateTab("AimbotV1", 12345678)

AimbotTab:CreateToggle({
    Name = "Enable Aimbot",
    CurrentValue = aimbotEnabled,
    Callback = function(value)
        aimbotEnabled = value
    end
})

AimbotTab:CreateToggle({
    Name = "Auto Lock",
    CurrentValue = autoLockEnabled,
    Callback = function(value)
        autoLockEnabled = value
    end
})

AimbotTab:CreateToggle({
    Name = "Trickshot Mode",
    CurrentValue = trickshotMode,
    Callback = function(value)
        trickshotMode = value
    end
})

AimbotTab:CreateDropdown({
    Name = "Aim Part",
    Options = {"Head", "Torso", "Random"},
    CurrentOption = aimPart,
    Callback = function(value)
        aimPart = value
    end
})

AimbotTab:CreateSlider({
    Name = "Smoothing Factor",
    Range = {1, 20},
    Increment = 1,
    CurrentValue = smoothingFactor,
    Callback = function(value)
        smoothingFactor = value
    end
})

AimbotTab:CreateSlider({
    Name = "FOV Radius",
    Range = {50, 300},
    Increment = 10,
    CurrentValue = fovRadius,
    Callback = function(value)
        fovRadius = value
    end
})

print("Script updated! Hitbox now consistently excludes teammates when toggled.")
